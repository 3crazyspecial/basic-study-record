## 复杂度分析

---

通过统计、监控，就能得到算法执行的时间和占用的内存大小，叫**事后统计法**

那我们为什么要做复杂度分析呢？是由于事后统计法

- 测试结果依赖测试环境
- 测试结果受数据规模的影响很大

空间复杂度分析

#### 大 O 复杂度表示法

定义： 不具体表示代码真正执行时间，表示代码随数据规模增长趋势，也叫作渐进时间复杂度，简称**时间复杂度**

算法的执行效率 约等同于 算法代码执行时间

预设条件：每行代码运行时间一样

```javascript
function cal(n) {
  var sum = 0; // 1 unit_time
  var i = 1; // 1 unit_time
  for (; i <= n; ++i) {
    // n unit_time
    sum += i; // n unit_time
  }
  return sum;
}
```

上面代码的执行时间就是 `(2n + 2) * unit_time`，

再看这一段代码

```javascript
function cal(n) {
  var sum = 0; // 1 unit_time
  var i = 1; // 1 unit_time
  var j = 1; // 1 unit_time
  for (; i <= n; ++i) {
    // n unit_time
    j = 1; // n unit_time
    for (; j <= n; ++j) {
      // n^2 unit_time
      sum += sum + i * j; // n^2 unit_time
    }
  }
}
```

可以看出上面代码的执行时间是 `(2n^2 + 2n + 3) * unit_time`

这个规律是 **所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比**

`T(n) = O(f(n))`

`T(n)` - 代码执行时间
`f(n)` - 每行代码执行次数总和

#### 怎么进行复杂度分析

大 O 只是表示一种变化趋势，通常忽略公式中常量，低阶，系数，记录一个最大的量级

**关注循环执行次数最多的一段代码**

所以上面第一段代码的复杂度为 `O(n)`

```javascript
function cal(n) {
  var sum = 0;
  var i = 1;
  for (; i <= n; ++i) {
    // n unit_time
    sum += i; // n unit_time
  }
  return sum;
}
```

**加法法则：总复杂度等于量级最大的那段代码的复杂度**

常量执行时间和 n 无关，不管是 10， 1000， 10000，只要是已知

时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。

如果 T1(n)=O(f(n))，T2(n)=O(g(n))，那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n)))=O(max(f(n), g(n)))

**乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

复杂度分析这个东西关键在于**熟练**。要多看案例，多分析

#### 几种常见的时间复杂度说明

**1. O(1)**

只是常量级的表示方法，不是只执行了一行代码

也可以理解成，只要代码的执行时间不随 n 的增长而增大，该时间复杂度都为 O(1)

**2. O(logn)、O(nlogn)**

```javascript
var i = 1;
while (i < n) P;
i *= 2;
```

这段代码其实是一个等比数列，2^x = n => x = log2^n
所以复杂度是 O(log2^n)，但是针对这一段代码

```javascript
var i = 1;
while (i < n) P;
i *= 3;
```

复杂度是 O(log3^n)

所以我们把其复杂度都记为 O(logn)

是因为，以该式子举例 log3^n 就等于 log3^2 \* log2^n，对数可以互相转换，常量忽略

对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示 O(logn)

那其实 O(nlogn) 就是 O(logn) 负责度的循环执行了 n 遍，乘法法则
